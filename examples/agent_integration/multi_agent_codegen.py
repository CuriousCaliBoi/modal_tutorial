"""
Multi-Agent Code Generation Example

Demonstrates how multiple agents can generate code in parallel, then aggregate
the results using Modal for coordination.
"""

import modal
from typing import List, Dict, Any, Optional
import json
import os

app = modal.App("multi-agent-codegen")

# Shared volume for coordinating code generation
shared_volume = modal.Volume.from_name("codegen-coordination", create_if_missing=True)

base_image = modal.Image.debian_slim().pip_install(
    "pydantic"
)


@app.function(
    image=base_image,
    volumes={"/shared": shared_volume}
)
def generate_code_parallel(
    task_config: Dict[str, Any],
    agent_id: str
) -> Dict[str, Any]:
    """
    Generate code for a specific task in parallel.
    
    Multiple agents can generate different parts of code simultaneously.
    
    Args:
        task_config: Dictionary with generation task (component, requirements, etc.)
        agent_id: ID of the agent generating code
    
    Returns:
        Dictionary with generated code and metadata
    """
    try:
        component_name = task_config.get("component", "unnamed")
        component_type = task_config.get("type", "function")
        requirements = task_config.get("requirements", "")
        
        # Simulate code generation (in practice, would use LLM or code generation tool)
        if component_type == "function":
            generated_code = f'''def {component_name}(*args, **kwargs):
    """
    Generated by {agent_id}
    Requirements: {requirements}
    """
    # TODO: Implement based on requirements
    pass
'''
        elif component_type == "class":
            generated_code = f'''class {component_name}:
    """
    Generated by {agent_id}
    Requirements: {requirements}
    """
    def __init__(self):
        pass
'''
        else:
            generated_code = f"# Generated by {agent_id}\n# Requirements: {requirements}\n"
        
        # Save generated code to shared volume
        code_dir = f"/shared/generated_code/{component_name}"
        os.makedirs(code_dir, exist_ok=True)
        
        code_path = f"{code_dir}/{component_name}.py"
        with open(code_path, "w") as f:
            f.write(generated_code)
        
        # Save metadata
        metadata = {
            "agent_id": agent_id,
            "component_name": component_name,
            "component_type": component_type,
            "requirements": requirements,
            "code_path": code_path,
            "timestamp": "2024-01-01T00:00:00Z"
        }
        
        metadata_path = f"{code_dir}/metadata.json"
        with open(metadata_path, "w") as f:
            json.dump(metadata, f, indent=2)
        
        # Update generation log
        log_path = "/shared/codegen_log.json"
        if os.path.exists(log_path):
            with open(log_path, "r") as f:
                log = json.load(f)
        else:
            log = []
        
        log.append(metadata)
        
        with open(log_path, "w") as f:
            json.dump(log, f, indent=2)
        
        # Commit volume changes
        shared_volume.commit()
        
        return {
            "status": "success",
            "agent_id": agent_id,
            "component_name": component_name,
            "code": generated_code,
            "code_path": code_path
        }
    except Exception as e:
        return {
            "status": "error",
            "agent_id": agent_id,
            "error": str(e)
        }


@app.function(
    image=base_image,
    volumes={"/shared": shared_volume}
)
def aggregate_generated_code(
    component_names: List[str]
) -> Dict[str, Any]:
    """
    Aggregate code generated by multiple agents into a single module.
    
    Args:
        component_names: List of component names to aggregate
    
    Returns:
        Dictionary with aggregated code
    """
    aggregated_code = []
    aggregated_code.append("# Generated code aggregated from multiple agents\n\n")
    
    for component_name in component_names:
        code_dir = f"/shared/generated_code/{component_name}"
        code_path = f"{code_dir}/{component_name}.py"
        
        if os.path.exists(code_path):
            with open(code_path, "r") as f:
                code = f.read()
            
            aggregated_code.append(f"# === {component_name} ===\n")
            aggregated_code.append(code)
            aggregated_code.append("\n\n")
    
    # Save aggregated code
    aggregated_path = "/shared/generated_code/aggregated.py"
    with open(aggregated_path, "w") as f:
        f.write("".join(aggregated_code))
    
    shared_volume.commit()
    
    return {
        "status": "success",
        "components": component_names,
        "aggregated_path": aggregated_path,
        "code": "".join(aggregated_code)
    }


@app.function(
    image=base_image,
    volumes={"/shared": shared_volume}
)
def get_generation_status() -> Dict[str, Any]:
    """Get status of all code generation tasks"""
    log_path = "/shared/codegen_log.json"
    
    if not os.path.exists(log_path):
        return {
            "status": "success",
            "components": [],
            "count": 0
        }
    
    with open(log_path, "r") as f:
        log = json.load(f)
    
    return {
        "status": "success",
        "components": log,
        "count": len(log)
    }


@app.function(image=base_image)
def coordinate_code_generation(
    generation_tasks: List[Dict[str, Any]],
    agent_ids: List[str]
) -> Dict[str, Any]:
    """
    Coordinate parallel code generation across multiple agents.
    
    Args:
        generation_tasks: List of code generation task configurations
        agent_ids: List of agent IDs (one per task)
    
    Returns:
        Dictionary with results from all generations
    """
    if len(generation_tasks) != len(agent_ids):
        return {
            "status": "error",
            "message": "generation_tasks and agent_ids must have same length"
        }
    
    # Execute all code generations in parallel
    results = list(generate_code_parallel.map(
        generation_tasks,
        agent_ids
    ))
    
    # Aggregate results
    successful = [r for r in results if r.get("status") == "success"]
    failed = [r for r in results if r.get("status") == "error"]
    
    # Extract component names for aggregation
    component_names = [
        r.get("component_name")
        for r in successful
        if r.get("component_name")
    ]
    
    # Aggregate generated code
    if component_names:
        aggregated = aggregate_generated_code.remote(component_names)
    else:
        aggregated = {"status": "skipped", "message": "No successful generations to aggregate"}
    
    return {
        "status": "completed",
        "total": len(results),
        "successful": len(successful),
        "failed": len(failed),
        "results": results,
        "aggregated": aggregated
    }


@app.local_entrypoint()
def example_multi_agent_codegen():
    """Example of multi-agent code generation"""
    
    # Example: Three agents generating different components in parallel
    generation_tasks = [
        {
            "component": "data_processor",
            "type": "class",
            "requirements": "Process data from CSV files"
        },
        {
            "component": "api_client",
            "type": "class",
            "requirements": "HTTP client for REST API"
        },
        {
            "component": "utils",
            "type": "function",
            "requirements": "Utility functions for string manipulation"
        }
    ]
    
    agent_ids = ["agent-codegen-1", "agent-codegen-2", "agent-codegen-3"]
    
    print("Generating code in parallel with multiple agents...")
    result = coordinate_code_generation.remote(generation_tasks, agent_ids)
    
    print(f"\nResults:")
    print(f"  Total: {result['total']}")
    print(f"  Successful: {result['successful']}")
    print(f"  Failed: {result['failed']}")
    
    # Show aggregated code
    if result['aggregated'].get('status') == 'success':
        print(f"\nAggregated code saved to: {result['aggregated']['aggregated_path']}")
        print("\nFirst 500 chars of aggregated code:")
        print(result['aggregated']['code'][:500])
    
    # Check status
    print("\nChecking generation status...")
    status = get_generation_status.remote()
    print(f"  Components generated: {status['count']}")
    
    for component in status["components"]:
        print(f"  - {component['component_name']} ({component['component_type']}) by {component['agent_id']}")
